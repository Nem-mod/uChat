.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_SHUTDOWN 3ossl"
.TH SSL_SHUTDOWN 3ossl "2023-02-11" "3.2.0-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_shutdown, SSL_shutdown_ex \- shut down a TLS/SSL or QUIC connection
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_shutdown(SSL *ssl);
\&
\& typedef struct ssl_shutdown_ex_args_st {
\&     uint64_t    quic_error_code;
\&     const char  *quic_reason;
\& } SSL_SHUTDOWN_EX_ARGS;
\&
\& _\|_owur int SSL_shutdown_ex(SSL *ssl, uint64_t flags,
\&                            const SSL_SHUTDOWN_EX_ARGS *args,
\&                            size_t args_len);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBSSL_shutdown()\fR shuts down an active \s-1TLS/SSL\s0 connection. It sends the
close_notify shutdown alert to the peer.
.PP
\&\fBSSL_shutdown()\fR tries to send the close_notify shutdown alert to the peer.
Whether the operation succeeds or not, the \s-1SSL_SENT_SHUTDOWN\s0 flag is set and
a currently open session is considered closed and good and will be kept in the
session cache for further reuse.
.PP
Note that \fBSSL_shutdown()\fR must not be called if a previous fatal error has
occurred on a connection i.e. if \fBSSL_get_error()\fR has returned \s-1SSL_ERROR_SYSCALL\s0
or \s-1SSL_ERROR_SSL.\s0
.PP
The shutdown procedure consists of two steps: sending of the close_notify
shutdown alert, and reception of the peer's close_notify shutdown alert.
The order of those two steps depends on the application.
.PP
It is acceptable for an application to only send its shutdown alert and
then close the underlying connection without waiting for the peer's response.
This way resources can be saved, as the process can already terminate or
serve another connection.
This should only be done when it is known that the other side will not send more
data, otherwise there is a risk of a truncation attack.
.PP
When a client only writes and never reads from the connection, and the server
has sent a session ticket to establish a session, the client might not be able
to resume the session because it did not received and process the session ticket
from the server.
In case the application wants to be able to resume the session, it is recommended to
do a complete shutdown procedure (bidirectional close_notify alerts).
.PP
When the underlying connection shall be used for more communications, the
complete shutdown procedure must be performed, so that the peers stay
synchronized.
.PP
\&\fBSSL_shutdown()\fR only closes the write direction.
It is not possible to call \fBSSL_write()\fR after calling \fBSSL_shutdown()\fR.
The read direction is closed by the peer.
.PP
The behaviour of \fBSSL_shutdown()\fR additionally depends on the underlying \s-1BIO.\s0
If the underlying \s-1BIO\s0 is \fBblocking\fR, \fBSSL_shutdown()\fR will only return once the
handshake step has been finished or an error occurred.
.PP
If the underlying \s-1BIO\s0 is \fBnonblocking\fR, \fBSSL_shutdown()\fR will also return
when the underlying \s-1BIO\s0 could not satisfy the needs of \fBSSL_shutdown()\fR
to continue the handshake. In this case a call to \fBSSL_get_error()\fR with the
return value of \fBSSL_shutdown()\fR will yield \fB\s-1SSL_ERROR_WANT_READ\s0\fR or
\&\fB\s-1SSL_ERROR_WANT_WRITE\s0\fR. The calling process then must repeat the call after
taking appropriate action to satisfy the needs of \fBSSL_shutdown()\fR.
The action depends on the underlying \s-1BIO.\s0 When using a nonblocking socket,
nothing is to be done, but \fBselect()\fR can be used to check for the required
condition. When using a buffering \s-1BIO,\s0 like a \s-1BIO\s0 pair, data must be written
into or retrieved out of the \s-1BIO\s0 before being able to continue.
.PP
After \fBSSL_shutdown()\fR returned 0, it is possible to call \fBSSL_shutdown()\fR again
to wait for the peer's close_notify alert.
\&\fBSSL_shutdown()\fR will return 1 in that case.
However, it is recommended to wait for it using \fBSSL_read()\fR instead.
.PP
\&\fBSSL_shutdown()\fR can be modified to only set the connection to \*(L"shutdown\*(R"
state but not actually send the close_notify alert messages,
see \fBSSL_CTX_set_quiet_shutdown\fR\|(3).
When \*(L"quiet shutdown\*(R" is enabled, \fBSSL_shutdown()\fR will always succeed
and return 1.
Note that this is not standard compliant behaviour.
It should only be done when the peer has a way to make sure all
data has been received and doesn't wait for the close_notify alert
message, otherwise an unexpected \s-1EOF\s0 will be reported.
.PP
There are implementations that do not send the required close_notify alert.
If there is a need to communicate with such an implementation, and it's clear
that all data has been received, do not wait for the peer's close_notify alert.
Waiting for the close_notify alert when the peer just closes the connection
will result in an error being generated.
The error can be ignored using the \fB\s-1SSL_OP_IGNORE_UNEXPECTED_EOF\s0\fR.
For more information see \fBSSL_CTX_set_options\fR\|(3).
.PP
\&\fBSSL_shutdown_ex()\fR is an extended version of \fBSSL_shutdown()\fR. If non-NULL, \fIargs\fR
must point to a \fB\s-1SSL_SHUTDOWN_EX_ARGS\s0\fR structure and \fIargs_len\fR must be set to
\&\f(CW\*(C`sizeof(SSL_SHUTDOWN_EX_ARGS)\*(C'\fR. The \fB\s-1SSL_SHUTDOWN_EX_ARGS\s0\fR structure must be
zero-initialized. If \fIargs\fR is \s-1NULL,\s0 the behaviour is the same as passing a
zero-initialised \fB\s-1SSL_SHUTDOWN_EX_ARGS\s0\fR structure. When used with a non-QUIC
\&\s-1SSL\s0 object, the arguments are ignored and the call functions identically to
\&\fBSSL_shutdown()\fR.
.PP
When used with a \s-1QUIC\s0 connection \s-1SSL\s0 object, \fBSSL_shutdown_ex()\fR initiates a \s-1QUIC\s0
immediate close. The \fIquic_error_code\fR field can be used to specify a 62\-bit
application error code to be signalled via \s-1QUIC.\s0 The value specified must be in
the range [0, 2**62\-1], else this call fails. \fIquic_reason\fR may optionally
specify a zero-terminated reason string to be signalled to the peer. If a reason
is not specified, a zero-length string is used as the reason. The reason string
is copied and need not remain allocated after the call to the function returns.
Reason strings are bounded by the path \s-1MTU\s0 and may be silently truncated if they
are too long to fit in a \s-1QUIC\s0 packet. The arguments are only used on the first
call to \fBSSL_shutdown_ex()\fR for a given \s-1QUIC\s0 connection \s-1SSL\s0 object.
.PP
When using \s-1QUIC,\s0 how an application uses \fBSSL_shutdown()\fR or \fBSSL_shutdown_ex()\fR has
implications for whether \s-1QUIC\s0 closes a connection in an RFC-compliant manner.
For discussion of these issues, and for discussion of the \fIflags\fR argument, see
\&\fBQUIC-SPECIFIC \s-1SHUTDOWN CONSIDERATIONS\s0\fR below.
.SS "First to close the connection"
.IX Subsection "First to close the connection"
When the application is the first party to send the close_notify
alert, \fBSSL_shutdown()\fR will only send the alert and then set the
\&\s-1SSL_SENT_SHUTDOWN\s0 flag (so that the session is considered good and will
be kept in the cache).
If successful, \fBSSL_shutdown()\fR will return 0.
.PP
If a unidirectional shutdown is enough (the underlying connection shall be
closed anyway), this first successful call to \fBSSL_shutdown()\fR is sufficient.
.PP
In order to complete the bidirectional shutdown handshake, the peer needs
to send back a close_notify alert.
The \s-1SSL_RECEIVED_SHUTDOWN\s0 flag will be set after receiving and processing
it.
.PP
The peer is still allowed to send data after receiving the close_notify
event.
When it is done sending data, it will send the close_notify alert.
\&\fBSSL_read()\fR should be called until all data is received.
\&\fBSSL_read()\fR will indicate the end of the peer data by returning <= 0
and \fBSSL_get_error()\fR returning \s-1SSL_ERROR_ZERO_RETURN.\s0
.SS "Peer closes the connection"
.IX Subsection "Peer closes the connection"
If the peer already sent the close_notify alert \fBand\fR it was
already processed implicitly inside another function
(\fBSSL_read\fR\|(3)), the \s-1SSL_RECEIVED_SHUTDOWN\s0 flag is set.
\&\fBSSL_read()\fR will return <= 0 in that case, and \fBSSL_get_error()\fR will return
\&\s-1SSL_ERROR_ZERO_RETURN.\s0
\&\fBSSL_shutdown()\fR will send the close_notify alert, set the \s-1SSL_SENT_SHUTDOWN\s0
flag.
If successful, \fBSSL_shutdown()\fR will return 1.
.PP
Whether \s-1SSL_RECEIVED_SHUTDOWN\s0 is already set can be checked using the
\&\fBSSL_get_shutdown()\fR (see also \fBSSL_set_shutdown\fR\|(3) call.
.SH "QUIC-SPECIFIC SHUTDOWN CONSIDERATIONS"
.IX Header "QUIC-SPECIFIC SHUTDOWN CONSIDERATIONS"
When using \s-1QUIC,\s0 \fBSSL_shutdown()\fR or \fBSSL_shutdown_ex()\fR causes any data written to
a stream which has not yet been sent to the peer to be written before the
shutdown process is considered complete. An exception to this is streams which
terminated in a non-normal fashion, for example due to a stream reset; only
streams which are non-terminated or which terminated in a normal fashion have
their pending send buffers flushed in this manner. This behaviour can be skipped
by setting the \fB\s-1SSL_SHUTDOWN_FLAG_NO_STREAM_FLUSH\s0\fR flag; in this case, data
remaining in stream send buffers may not be transmitted to the peer. This flag
may be used when a non-normal application condition has occurred and the
delivery of data written to streams via \fBSSL_write\fR\|(3) is no longer relevant.
.PP
Aspects of how \s-1QUIC\s0 handles connection closure must be taken into account by
applications. Ordinarily, \s-1QUIC\s0 expects a connection to continue to be serviced
for a substantial period of time after it is nominally closed. This is necessary
to ensure that any connection closure notification sent to the peer was
successfully received. However, a consequence of this is that a fully
RFC-compliant \s-1QUIC\s0 connection closure process could take of the order of
seconds. This may be unsuitable for some applications, such as short-lived
processes which need to exit immediately after completing an application-layer
transaction.
.PP
As such, there are two shutdown modes available to users of \s-1QUIC\s0 connection \s-1SSL\s0
objects:
.IP "\s-1RFC\s0 compliant shutdown mode" 4
.IX Item "RFC compliant shutdown mode"
This is the default behaviour. The shutdown process may take a period of time up
to three times the current estimated \s-1RTT\s0 to the peer. It is possible for the
closure process to complete much faster in some circumstances but this cannot be
relied upon.
.Sp
In blocking mode, the function will return once the closure process is complete.
In nonblocking mode, \fBSSL_shutdown_ex()\fR should be called until it returns 1,
indicating the closure process is complete and the connection is now fully shut
down.
.IP "Rapid shutdown mode" 4
.IX Item "Rapid shutdown mode"
In this mode, the peer is notified of connection closure on a best effort basis
by sending a single \s-1QUIC\s0 packet. If that \s-1QUIC\s0 packet is lost, the peer will not
know that the connection has terminated until the negotiated idle timeout (if
any) expires.
.Sp
This will generally return 0 on success, indicating that the connection has not
yet been fully shut down (unless it has already done so, in which case it will
return 1).
.PP
If \fB\s-1SSL_SHUTDOWN_FLAG_RAPID\s0\fR is specified in \fIflags\fR, a rapid shutdown is
performed, otherwise an RFC-compliant shutdown is performed.
.PP
If an application calls \fBSSL_shutdown_ex()\fR with \fB\s-1SSL_SHUTDOWN_FLAG_RAPID\s0\fR, an
application can subsequently change its mind about performing a rapid shutdown
by making a subsequent call to \fBSSL_shutdown_ex()\fR without the flag set.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
For both \fBSSL_shutdown()\fR and \fBSSL_shutdown_ex()\fR the following return values can occur:
.IP "0" 4
The shutdown process is ongoing and has not yet completed.
.Sp
For \s-1TLS\s0 and \s-1DTLS,\s0 this means that a close_notify alert has been sent but the
peer has not yet replied in turn with its own close_notify.
.Sp
For \s-1QUIC\s0 connection \s-1SSL\s0 objects, a \s-1CONNECTION_CLOSE\s0 frame may have been
sent but the connection closure process has not yet completed.
.Sp
Unlike most other functions, returning 0 does not indicate an error.
\&\fBSSL_get_error\fR\|(3) should not be called; it may misleadingly indicate an error
even though no error occurred.
.IP "1" 4
.IX Item "1"
The shutdown was successfully completed.
.Sp
For \s-1TLS\s0 and \s-1DTLS,\s0 this means that a close_notify alert was sent and the peer's
close_notify alert was received.
.Sp
For \s-1QUIC\s0 connection \s-1SSL\s0 objects, this means that the connection closure process
has completed.
.IP "<0" 4
.IX Item "<0"
The shutdown was not successful.
Call \fBSSL_get_error\fR\|(3) with the return value \fBret\fR to find out the reason.
It can occur if an action is needed to continue the operation for nonblocking
BIOs.
.Sp
It can also occur when not all data was read using \fBSSL_read()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBSSL_get_error\fR\|(3), \fBSSL_connect\fR\|(3),
\&\fBSSL_accept\fR\|(3), \fBSSL_set_shutdown\fR\|(3),
\&\fBSSL_CTX_set_quiet_shutdown\fR\|(3), \fBSSL_CTX_set_options\fR\|(3)
\&\fBSSL_clear\fR\|(3), \fBSSL_free\fR\|(3),
\&\fBssl\fR\|(7), \fBbio\fR\|(7)
.SH "HISTORY"
.IX Header "HISTORY"
The \fBSSL_shutdown_ex()\fR function was added in OpenSSL 3.2.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000\-2020 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
